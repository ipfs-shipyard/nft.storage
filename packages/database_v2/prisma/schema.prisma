// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

generator dbml {
   provider = "prisma-dbml-generator"
}

//Enums
enum resource_status {
  Queued                //  Resource was queued to be processed.
  URIParseFailed        //  URI is either malformed or the protocol is not supported.
  ContentFetchFailed    //  Was unable to fetch the content.
  PinRequestFailed      //  Failed to complete a pin request.
  ContentLinked         //  Corresponding content was linked.
}

enum nft_asset_status {
  Queued                //  Token asset was queued (for the analyzer to process).
  URIParseFailed        //  tokenURI is either malformed or the protocol is not supported.
  ContentFetchFailed    //  Was unable to fetch the content.
  ContentParseFailed    //  Parsing ERC721 metadata failed.
  PinRequestFailed      //  Failed to create a metadata pin request.
  Linked                //  Metadata was parsed and all the resources were linked.
}

enum pin_status {
    ClusterError
    PinError
    PinQueued
    Pinned
    Pinning
    Remote
    Sharded
    Undefined
    UnpinError
    UnpinQueued
    Unpinned
    Unpinning
}

enum pin_service {
    Pinata
    IpfsCluster
}

//Models
model block {
    hash                String          @id @unique //the hash of the block
    number              Int             @unique     //the block number
    nfts                nfts_by_blocks[]

    updated_at          DateTime        @default(now())
    inserted_at         DateTime        @default(now())
}

model nft {
    id                  String          @id @unique
    token_id            String
    mint_time           DateTime
    token_uri           String
    // Present when ERC721metadata interface is implemented.
    nft_asset           nft_asset       @relation(fields: [token_uri], references: [token_uri])
    blocks              nfts_by_blocks[]
    contract_id         String
    contract            contract        @relation(fields: [contract_id], references: [id])

    owner_id            String
    owner               owner           @relation(fields: [owner_id], references: [id])

    imported            erc721_import_by_nft[]

    updated_at          DateTime        @default(now())
    inserted_at         DateTime        @default(now())
}

model owner {
    id                  String          @id @unique
    nfts                nft[]

    updated_at          DateTime        @default(now())
    inserted_at         DateTime        @default(now())
}

model nfts_by_blocks {
    block               block           @relation(fields: [block_hash], references: [hash])
    block_hash          String          //scalar for above relation
    token               nft             @relation(fields: [nft_id], references: [id])
    nft_id              String          //scalar for above relation

    updated_at          DateTime        @default(now())
    inserted_at         DateTime        @default(now())
    @@id([block_hash, nft_id])
}

model nft_asset {
    token_uri           String          @id @unique
    referrers           nft[]

    ipfs_URL            String?
    metadata            metadata?
    status              nft_asset_status
    status_text         String

    updated_at          DateTime        @default(now())
    inserted_at         DateTime        @default(now())
}

model metadata {
    content_cid         String          @id @unique

    token_uri           String          @unique
    nft_asset           nft_asset       @relation(fields: [token_uri], references: [token_uri])

    name                String                       //identifies the asset this token represents
    description         String          @db.Text()   //describes the asset this token represents

    image_uri           String          @db.Text()
    resources           resources_by_metadata[]

    updated_at          DateTime        @default(now())
    inserted_at         DateTime        @default(now())
}

model resource {
    uri                 String          @id @unique //uri with which resource identified

    referrers           resources_by_metadata[]
    status              resource_status
    status_text         String?

    ipfs_url            String?         @unique     //ipfs:// url if `uri` was referring to gateway URL.

    // Content referrerced by this resource. When `ipfsURL` is derived content
    // archiving job will simply pin content by that URL and update resource linking
    // resource to it. If however `ipfsURL` could not be derived archiving job will
    // attempt to fetch the content from `uri` and pin it again linkking resource
    // to it.

    // Content field is only going to be present when resource has a `ContentLinked`
    content_cid         String?         //CID corresponding to this resource once it is pinned.
    content             content?        @relation(fields: [content_cid], references: [cid])

    updated_at          DateTime        @default(now())
    inserted_at         DateTime        @default(now())
}

//Explicit Join table for metadata and resources.
model resources_by_metadata {
    metadata_cid         String
    metadata            metadata        @relation(fields: [metadata_cid], references: [content_cid])

    resource_uri        String
    resource            resource        @relation(fields: [resource_uri], references: [uri])

    updated_at          DateTime        @default(now())
    inserted_at         DateTime        @default(now())
    @@id([metadata_cid, resource_uri])
}


model content {
    cid                 String          @id @unique
    resources           resource[]
    dag_size            Int?
    pins                pin[]

    updated_at          DateTime        @default(now())
    inserted_at         DateTime        @default(now())
}

model pin {
    id                  BigInt          @id @unique @default(autoincrement())
    content_cid         String
    content             content         @relation(fields: [content_cid], references: [cid]) //content being pinned
    service             pin_service
    status              pin_status                      // pinning status at this location
    status_text         String?         @db.Text()      // human readable description of pin status (needed in edge cases)

    updated_at          DateTime        @default(now())
    inserted_at         DateTime        @default(now())
}

model contract {
    id                       String     @id @unique
    name                     String?                      // descriptive name for a collection of NFTs
    symbol                   String?                      // abbreviate name for NFTs
    supports_eip721_metadata Boolean
    nfts                     nft[]

    updated_at              DateTime    @default(now())
    inserted_at             DateTime    @default(now())
}

model erc721_import {
    id                 String          @id @unique          // import start cursor
    next_id            String                               // new cursor after this import
    tokens             erc721_import_by_nft[]               // tokens that were imported

    updated_at         DateTime        @default(now())
    inserted_at        DateTime        @default(now())
}

//Join import respults to tokens (Many to Many)
model erc721_import_by_nft {
    erc721_import                      erc721_import                @relation(fields: [erc721_import_id], references: [id])
    erc721_import_id                   String                         //scalar for above relation
    token                              nft                          @relation(fields: [nft_id], references: [id])
    nft_id                             String                         //scalar for above relation

    updated_at          DateTime      @default(now())
    inserted_at         DateTime      @default(now())
    @@id([erc721_import_id, nft_id])
}