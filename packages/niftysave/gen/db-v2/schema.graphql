schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  measured in seconds
  """
  ttl: Int! = 60

  """
  refresh the cache entry
  """
  refresh: Boolean! = false
) on QUERY

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "blockchain_block"
"""
type blockchain_block {
  hash: String!
  inserted_at: timestamp!
  number: Int!
  updated_at: timestamp!
}

"""
aggregated selection of "blockchain_block"
"""
type blockchain_block_aggregate {
  aggregate: blockchain_block_aggregate_fields
  nodes: [blockchain_block!]!
}

"""
aggregate fields of "blockchain_block"
"""
type blockchain_block_aggregate_fields {
  avg: blockchain_block_avg_fields
  count(columns: [blockchain_block_select_column!], distinct: Boolean): Int!
  max: blockchain_block_max_fields
  min: blockchain_block_min_fields
  stddev: blockchain_block_stddev_fields
  stddev_pop: blockchain_block_stddev_pop_fields
  stddev_samp: blockchain_block_stddev_samp_fields
  sum: blockchain_block_sum_fields
  var_pop: blockchain_block_var_pop_fields
  var_samp: blockchain_block_var_samp_fields
  variance: blockchain_block_variance_fields
}

"""
aggregate avg on columns
"""
type blockchain_block_avg_fields {
  number: Float
}

"""
Boolean expression to filter rows from the table "blockchain_block". All fields are combined with a logical 'AND'.
"""
input blockchain_block_bool_exp {
  _and: [blockchain_block_bool_exp!]
  _not: blockchain_block_bool_exp
  _or: [blockchain_block_bool_exp!]
  hash: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  number: Int_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "blockchain_block"
"""
enum blockchain_block_constraint {
  """
  unique or primary key constraint
  """
  blockchain_block_pkey

  """
  unique or primary key constraint
  """
  unique_blockchain_block_hash
}

"""
input type for incrementing numeric columns in table "blockchain_block"
"""
input blockchain_block_inc_input {
  number: Int
}

"""
input type for inserting data into table "blockchain_block"
"""
input blockchain_block_insert_input {
  hash: String
  inserted_at: timestamp
  number: Int
  updated_at: timestamp
}

"""
aggregate max on columns
"""
type blockchain_block_max_fields {
  hash: String
  inserted_at: timestamp
  number: Int
  updated_at: timestamp
}

"""
aggregate min on columns
"""
type blockchain_block_min_fields {
  hash: String
  inserted_at: timestamp
  number: Int
  updated_at: timestamp
}

"""
response of any mutation on the table "blockchain_block"
"""
type blockchain_block_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [blockchain_block!]!
}

"""
on conflict condition type for table "blockchain_block"
"""
input blockchain_block_on_conflict {
  constraint: blockchain_block_constraint!
  update_columns: [blockchain_block_update_column!]! = []
  where: blockchain_block_bool_exp
}

"""
Ordering options when selecting data from "blockchain_block".
"""
input blockchain_block_order_by {
  hash: order_by
  inserted_at: order_by
  number: order_by
  updated_at: order_by
}

"""
primary key columns input for table: blockchain_block
"""
input blockchain_block_pk_columns_input {
  hash: String!
}

"""
select columns of table "blockchain_block"
"""
enum blockchain_block_select_column {
  """
  column name
  """
  hash

  """
  column name
  """
  inserted_at

  """
  column name
  """
  number

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "blockchain_block"
"""
input blockchain_block_set_input {
  hash: String
  inserted_at: timestamp
  number: Int
  updated_at: timestamp
}

"""
aggregate stddev on columns
"""
type blockchain_block_stddev_fields {
  number: Float
}

"""
aggregate stddev_pop on columns
"""
type blockchain_block_stddev_pop_fields {
  number: Float
}

"""
aggregate stddev_samp on columns
"""
type blockchain_block_stddev_samp_fields {
  number: Float
}

"""
aggregate sum on columns
"""
type blockchain_block_sum_fields {
  number: Int
}

"""
update columns of table "blockchain_block"
"""
enum blockchain_block_update_column {
  """
  column name
  """
  hash

  """
  column name
  """
  inserted_at

  """
  column name
  """
  number

  """
  column name
  """
  updated_at
}

"""
aggregate var_pop on columns
"""
type blockchain_block_var_pop_fields {
  number: Float
}

"""
aggregate var_samp on columns
"""
type blockchain_block_var_samp_fields {
  number: Float
}

"""
aggregate variance on columns
"""
type blockchain_block_variance_fields {
  number: Float
}

"""
columns and relationships of "blockchain_contract"
"""
type blockchain_contract {
  id: String!
  inserted_at: timestamp!
  name: String
  supports_eip721_metadata: Boolean!
  symbol: String
  updated_at: timestamp!
}

"""
aggregated selection of "blockchain_contract"
"""
type blockchain_contract_aggregate {
  aggregate: blockchain_contract_aggregate_fields
  nodes: [blockchain_contract!]!
}

"""
aggregate fields of "blockchain_contract"
"""
type blockchain_contract_aggregate_fields {
  count(columns: [blockchain_contract_select_column!], distinct: Boolean): Int!
  max: blockchain_contract_max_fields
  min: blockchain_contract_min_fields
}

"""
Boolean expression to filter rows from the table "blockchain_contract". All fields are combined with a logical 'AND'.
"""
input blockchain_contract_bool_exp {
  _and: [blockchain_contract_bool_exp!]
  _not: blockchain_contract_bool_exp
  _or: [blockchain_contract_bool_exp!]
  id: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  name: String_comparison_exp
  supports_eip721_metadata: Boolean_comparison_exp
  symbol: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "blockchain_contract"
"""
enum blockchain_contract_constraint {
  """
  unique or primary key constraint
  """
  blockchain_contract_pkey
}

"""
input type for inserting data into table "blockchain_contract"
"""
input blockchain_contract_insert_input {
  id: String
  inserted_at: timestamp
  name: String
  supports_eip721_metadata: Boolean
  symbol: String
  updated_at: timestamp
}

"""
aggregate max on columns
"""
type blockchain_contract_max_fields {
  id: String
  inserted_at: timestamp
  name: String
  symbol: String
  updated_at: timestamp
}

"""
aggregate min on columns
"""
type blockchain_contract_min_fields {
  id: String
  inserted_at: timestamp
  name: String
  symbol: String
  updated_at: timestamp
}

"""
response of any mutation on the table "blockchain_contract"
"""
type blockchain_contract_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [blockchain_contract!]!
}

"""
on conflict condition type for table "blockchain_contract"
"""
input blockchain_contract_on_conflict {
  constraint: blockchain_contract_constraint!
  update_columns: [blockchain_contract_update_column!]! = []
  where: blockchain_contract_bool_exp
}

"""
Ordering options when selecting data from "blockchain_contract".
"""
input blockchain_contract_order_by {
  id: order_by
  inserted_at: order_by
  name: order_by
  supports_eip721_metadata: order_by
  symbol: order_by
  updated_at: order_by
}

"""
primary key columns input for table: blockchain_contract
"""
input blockchain_contract_pk_columns_input {
  id: String!
}

"""
select columns of table "blockchain_contract"
"""
enum blockchain_contract_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  name

  """
  column name
  """
  supports_eip721_metadata

  """
  column name
  """
  symbol

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "blockchain_contract"
"""
input blockchain_contract_set_input {
  id: String
  inserted_at: timestamp
  name: String
  supports_eip721_metadata: Boolean
  symbol: String
  updated_at: timestamp
}

"""
update columns of table "blockchain_contract"
"""
enum blockchain_contract_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  name

  """
  column name
  """
  supports_eip721_metadata

  """
  column name
  """
  symbol

  """
  column name
  """
  updated_at
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "content"
"""
type content {
  cid: String!
  dag_size: Int
  inserted_at: timestamp!
  updated_at: timestamp!
}

"""
aggregated selection of "content"
"""
type content_aggregate {
  aggregate: content_aggregate_fields
  nodes: [content!]!
}

"""
aggregate fields of "content"
"""
type content_aggregate_fields {
  avg: content_avg_fields
  count(columns: [content_select_column!], distinct: Boolean): Int!
  max: content_max_fields
  min: content_min_fields
  stddev: content_stddev_fields
  stddev_pop: content_stddev_pop_fields
  stddev_samp: content_stddev_samp_fields
  sum: content_sum_fields
  var_pop: content_var_pop_fields
  var_samp: content_var_samp_fields
  variance: content_variance_fields
}

"""
aggregate avg on columns
"""
type content_avg_fields {
  dag_size: Float
}

"""
Boolean expression to filter rows from the table "content". All fields are combined with a logical 'AND'.
"""
input content_bool_exp {
  _and: [content_bool_exp!]
  _not: content_bool_exp
  _or: [content_bool_exp!]
  cid: String_comparison_exp
  dag_size: Int_comparison_exp
  inserted_at: timestamp_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "content"
"""
enum content_constraint {
  """
  unique or primary key constraint
  """
  content_pkey
}

"""
input type for incrementing numeric columns in table "content"
"""
input content_inc_input {
  dag_size: Int
}

"""
input type for inserting data into table "content"
"""
input content_insert_input {
  cid: String
  dag_size: Int
  inserted_at: timestamp
  updated_at: timestamp
}

"""
aggregate max on columns
"""
type content_max_fields {
  cid: String
  dag_size: Int
  inserted_at: timestamp
  updated_at: timestamp
}

"""
aggregate min on columns
"""
type content_min_fields {
  cid: String
  dag_size: Int
  inserted_at: timestamp
  updated_at: timestamp
}

"""
response of any mutation on the table "content"
"""
type content_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [content!]!
}

"""
on conflict condition type for table "content"
"""
input content_on_conflict {
  constraint: content_constraint!
  update_columns: [content_update_column!]! = []
  where: content_bool_exp
}

"""
Ordering options when selecting data from "content".
"""
input content_order_by {
  cid: order_by
  dag_size: order_by
  inserted_at: order_by
  updated_at: order_by
}

"""
primary key columns input for table: content
"""
input content_pk_columns_input {
  cid: String!
}

"""
select columns of table "content"
"""
enum content_select_column {
  """
  column name
  """
  cid

  """
  column name
  """
  dag_size

  """
  column name
  """
  inserted_at

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "content"
"""
input content_set_input {
  cid: String
  dag_size: Int
  inserted_at: timestamp
  updated_at: timestamp
}

"""
aggregate stddev on columns
"""
type content_stddev_fields {
  dag_size: Float
}

"""
aggregate stddev_pop on columns
"""
type content_stddev_pop_fields {
  dag_size: Float
}

"""
aggregate stddev_samp on columns
"""
type content_stddev_samp_fields {
  dag_size: Float
}

"""
aggregate sum on columns
"""
type content_sum_fields {
  dag_size: Int
}

"""
update columns of table "content"
"""
enum content_update_column {
  """
  column name
  """
  cid

  """
  column name
  """
  dag_size

  """
  column name
  """
  inserted_at

  """
  column name
  """
  updated_at
}

"""
aggregate var_pop on columns
"""
type content_var_pop_fields {
  dag_size: Float
}

"""
aggregate var_samp on columns
"""
type content_var_samp_fields {
  dag_size: Float
}

"""
aggregate variance on columns
"""
type content_variance_fields {
  dag_size: Float
}

"""
columns and relationships of "erc721_import"
"""
type erc721_import {
  id: String!
  inserted_at: timestamp!
  next_id: String!
  updated_at: timestamp!
}

"""
aggregated selection of "erc721_import"
"""
type erc721_import_aggregate {
  aggregate: erc721_import_aggregate_fields
  nodes: [erc721_import!]!
}

"""
aggregate fields of "erc721_import"
"""
type erc721_import_aggregate_fields {
  count(columns: [erc721_import_select_column!], distinct: Boolean): Int!
  max: erc721_import_max_fields
  min: erc721_import_min_fields
}

"""
Boolean expression to filter rows from the table "erc721_import". All fields are combined with a logical 'AND'.
"""
input erc721_import_bool_exp {
  _and: [erc721_import_bool_exp!]
  _not: erc721_import_bool_exp
  _or: [erc721_import_bool_exp!]
  id: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  next_id: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
columns and relationships of "erc721_import_by_nft"
"""
type erc721_import_by_nft {
  erc721_import_id: String!
  inserted_at: timestamp!
  nft_id: String!
  updated_at: timestamp!
}

"""
aggregated selection of "erc721_import_by_nft"
"""
type erc721_import_by_nft_aggregate {
  aggregate: erc721_import_by_nft_aggregate_fields
  nodes: [erc721_import_by_nft!]!
}

"""
aggregate fields of "erc721_import_by_nft"
"""
type erc721_import_by_nft_aggregate_fields {
  count(columns: [erc721_import_by_nft_select_column!], distinct: Boolean): Int!
  max: erc721_import_by_nft_max_fields
  min: erc721_import_by_nft_min_fields
}

"""
Boolean expression to filter rows from the table "erc721_import_by_nft". All fields are combined with a logical 'AND'.
"""
input erc721_import_by_nft_bool_exp {
  _and: [erc721_import_by_nft_bool_exp!]
  _not: erc721_import_by_nft_bool_exp
  _or: [erc721_import_by_nft_bool_exp!]
  erc721_import_id: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  nft_id: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "erc721_import_by_nft"
"""
enum erc721_import_by_nft_constraint {
  """
  unique or primary key constraint
  """
  erc721_import_by_nft_pkey
}

"""
input type for inserting data into table "erc721_import_by_nft"
"""
input erc721_import_by_nft_insert_input {
  erc721_import_id: String
  inserted_at: timestamp
  nft_id: String
  updated_at: timestamp
}

"""
aggregate max on columns
"""
type erc721_import_by_nft_max_fields {
  erc721_import_id: String
  inserted_at: timestamp
  nft_id: String
  updated_at: timestamp
}

"""
aggregate min on columns
"""
type erc721_import_by_nft_min_fields {
  erc721_import_id: String
  inserted_at: timestamp
  nft_id: String
  updated_at: timestamp
}

"""
response of any mutation on the table "erc721_import_by_nft"
"""
type erc721_import_by_nft_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [erc721_import_by_nft!]!
}

"""
on conflict condition type for table "erc721_import_by_nft"
"""
input erc721_import_by_nft_on_conflict {
  constraint: erc721_import_by_nft_constraint!
  update_columns: [erc721_import_by_nft_update_column!]! = []
  where: erc721_import_by_nft_bool_exp
}

"""
Ordering options when selecting data from "erc721_import_by_nft".
"""
input erc721_import_by_nft_order_by {
  erc721_import_id: order_by
  inserted_at: order_by
  nft_id: order_by
  updated_at: order_by
}

"""
primary key columns input for table: erc721_import_by_nft
"""
input erc721_import_by_nft_pk_columns_input {
  erc721_import_id: String!
  nft_id: String!
}

"""
select columns of table "erc721_import_by_nft"
"""
enum erc721_import_by_nft_select_column {
  """
  column name
  """
  erc721_import_id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  nft_id

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "erc721_import_by_nft"
"""
input erc721_import_by_nft_set_input {
  erc721_import_id: String
  inserted_at: timestamp
  nft_id: String
  updated_at: timestamp
}

"""
update columns of table "erc721_import_by_nft"
"""
enum erc721_import_by_nft_update_column {
  """
  column name
  """
  erc721_import_id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  nft_id

  """
  column name
  """
  updated_at
}

"""
unique or primary key constraints on table "erc721_import"
"""
enum erc721_import_constraint {
  """
  unique or primary key constraint
  """
  erc721_import_pkey
}

"""
input type for inserting data into table "erc721_import"
"""
input erc721_import_insert_input {
  id: String
  inserted_at: timestamp
  next_id: String
  updated_at: timestamp
}

"""
aggregate max on columns
"""
type erc721_import_max_fields {
  id: String
  inserted_at: timestamp
  next_id: String
  updated_at: timestamp
}

"""
aggregate min on columns
"""
type erc721_import_min_fields {
  id: String
  inserted_at: timestamp
  next_id: String
  updated_at: timestamp
}

"""
response of any mutation on the table "erc721_import"
"""
type erc721_import_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [erc721_import!]!
}

"""
on conflict condition type for table "erc721_import"
"""
input erc721_import_on_conflict {
  constraint: erc721_import_constraint!
  update_columns: [erc721_import_update_column!]! = []
  where: erc721_import_bool_exp
}

"""
Ordering options when selecting data from "erc721_import".
"""
input erc721_import_order_by {
  id: order_by
  inserted_at: order_by
  next_id: order_by
  updated_at: order_by
}

"""
primary key columns input for table: erc721_import
"""
input erc721_import_pk_columns_input {
  id: String!
}

"""
select columns of table "erc721_import"
"""
enum erc721_import_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  next_id

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "erc721_import"
"""
input erc721_import_set_input {
  id: String
  inserted_at: timestamp
  next_id: String
  updated_at: timestamp
}

"""
update columns of table "erc721_import"
"""
enum erc721_import_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  next_id

  """
  column name
  """
  updated_at
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar jsonb

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """
  is the column contained in the given json value
  """
  _contained_in: jsonb

  """
  does the column contain the given json value at the top level
  """
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """
  does the string exist as a top-level key in the column
  """
  _has_key: String

  """
  do all of these strings exist as top-level keys in the column
  """
  _has_keys_all: [String!]

  """
  do any of these strings exist as top-level keys in the column
  """
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "blockchain_block"
  """
  delete_blockchain_block(
    """
    filter the rows which have to be deleted
    """
    where: blockchain_block_bool_exp!
  ): blockchain_block_mutation_response

  """
  delete single row from the table: "blockchain_block"
  """
  delete_blockchain_block_by_pk(hash: String!): blockchain_block

  """
  delete data from the table: "blockchain_contract"
  """
  delete_blockchain_contract(
    """
    filter the rows which have to be deleted
    """
    where: blockchain_contract_bool_exp!
  ): blockchain_contract_mutation_response

  """
  delete single row from the table: "blockchain_contract"
  """
  delete_blockchain_contract_by_pk(id: String!): blockchain_contract

  """
  delete data from the table: "content"
  """
  delete_content(
    """
    filter the rows which have to be deleted
    """
    where: content_bool_exp!
  ): content_mutation_response

  """
  delete single row from the table: "content"
  """
  delete_content_by_pk(cid: String!): content

  """
  delete data from the table: "erc721_import"
  """
  delete_erc721_import(
    """
    filter the rows which have to be deleted
    """
    where: erc721_import_bool_exp!
  ): erc721_import_mutation_response

  """
  delete data from the table: "erc721_import_by_nft"
  """
  delete_erc721_import_by_nft(
    """
    filter the rows which have to be deleted
    """
    where: erc721_import_by_nft_bool_exp!
  ): erc721_import_by_nft_mutation_response

  """
  delete single row from the table: "erc721_import_by_nft"
  """
  delete_erc721_import_by_nft_by_pk(
    erc721_import_id: String!
    nft_id: String!
  ): erc721_import_by_nft

  """
  delete single row from the table: "erc721_import"
  """
  delete_erc721_import_by_pk(id: String!): erc721_import

  """
  delete data from the table: "nft"
  """
  delete_nft(
    """
    filter the rows which have to be deleted
    """
    where: nft_bool_exp!
  ): nft_mutation_response

  """
  delete data from the table: "nft_asset"
  """
  delete_nft_asset(
    """
    filter the rows which have to be deleted
    """
    where: nft_asset_bool_exp!
  ): nft_asset_mutation_response

  """
  delete single row from the table: "nft_asset"
  """
  delete_nft_asset_by_pk(token_uri: String!): nft_asset

  """
  delete single row from the table: "nft"
  """
  delete_nft_by_pk(id: String!): nft

  """
  delete data from the table: "nft_metadata"
  """
  delete_nft_metadata(
    """
    filter the rows which have to be deleted
    """
    where: nft_metadata_bool_exp!
  ): nft_metadata_mutation_response

  """
  delete single row from the table: "nft_metadata"
  """
  delete_nft_metadata_by_pk(content_cid: String!): nft_metadata

  """
  delete data from the table: "nft_owner"
  """
  delete_nft_owner(
    """
    filter the rows which have to be deleted
    """
    where: nft_owner_bool_exp!
  ): nft_owner_mutation_response

  """
  delete single row from the table: "nft_owner"
  """
  delete_nft_owner_by_pk(id: String!): nft_owner

  """
  delete data from the table: "nfts_by_blockchain_blocks"
  """
  delete_nfts_by_blockchain_blocks(
    """
    filter the rows which have to be deleted
    """
    where: nfts_by_blockchain_blocks_bool_exp!
  ): nfts_by_blockchain_blocks_mutation_response

  """
  delete single row from the table: "nfts_by_blockchain_blocks"
  """
  delete_nfts_by_blockchain_blocks_by_pk(
    blockchain_block_hash: String!
    nft_id: String!
  ): nfts_by_blockchain_blocks

  """
  delete data from the table: "niftysave_migration"
  """
  delete_niftysave_migration(
    """
    filter the rows which have to be deleted
    """
    where: niftysave_migration_bool_exp!
  ): niftysave_migration_mutation_response

  """
  delete single row from the table: "niftysave_migration"
  """
  delete_niftysave_migration_by_pk(id: String!): niftysave_migration

  """
  delete data from the table: "other_nft_resources"
  """
  delete_other_nft_resources(
    """
    filter the rows which have to be deleted
    """
    where: other_nft_resources_bool_exp!
  ): other_nft_resources_mutation_response

  """
  delete single row from the table: "other_nft_resources"
  """
  delete_other_nft_resources_by_pk(
    content_cid: String!
    resource_uri: String!
  ): other_nft_resources

  """
  delete data from the table: "pin"
  """
  delete_pin(
    """
    filter the rows which have to be deleted
    """
    where: pin_bool_exp!
  ): pin_mutation_response

  """
  delete single row from the table: "pin"
  """
  delete_pin_by_pk(id: bigint!): pin

  """
  delete data from the table: "resource"
  """
  delete_resource(
    """
    filter the rows which have to be deleted
    """
    where: resource_bool_exp!
  ): resource_mutation_response

  """
  delete single row from the table: "resource"
  """
  delete_resource_by_pk(uri: String!): resource

  """
  insert data into the table: "blockchain_block"
  """
  insert_blockchain_block(
    """
    the rows to be inserted
    """
    objects: [blockchain_block_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: blockchain_block_on_conflict
  ): blockchain_block_mutation_response

  """
  insert a single row into the table: "blockchain_block"
  """
  insert_blockchain_block_one(
    """
    the row to be inserted
    """
    object: blockchain_block_insert_input!

    """
    on conflict condition
    """
    on_conflict: blockchain_block_on_conflict
  ): blockchain_block

  """
  insert data into the table: "blockchain_contract"
  """
  insert_blockchain_contract(
    """
    the rows to be inserted
    """
    objects: [blockchain_contract_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: blockchain_contract_on_conflict
  ): blockchain_contract_mutation_response

  """
  insert a single row into the table: "blockchain_contract"
  """
  insert_blockchain_contract_one(
    """
    the row to be inserted
    """
    object: blockchain_contract_insert_input!

    """
    on conflict condition
    """
    on_conflict: blockchain_contract_on_conflict
  ): blockchain_contract

  """
  insert data into the table: "content"
  """
  insert_content(
    """
    the rows to be inserted
    """
    objects: [content_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: content_on_conflict
  ): content_mutation_response

  """
  insert a single row into the table: "content"
  """
  insert_content_one(
    """
    the row to be inserted
    """
    object: content_insert_input!

    """
    on conflict condition
    """
    on_conflict: content_on_conflict
  ): content

  """
  insert data into the table: "erc721_import"
  """
  insert_erc721_import(
    """
    the rows to be inserted
    """
    objects: [erc721_import_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: erc721_import_on_conflict
  ): erc721_import_mutation_response

  """
  insert data into the table: "erc721_import_by_nft"
  """
  insert_erc721_import_by_nft(
    """
    the rows to be inserted
    """
    objects: [erc721_import_by_nft_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: erc721_import_by_nft_on_conflict
  ): erc721_import_by_nft_mutation_response

  """
  insert a single row into the table: "erc721_import_by_nft"
  """
  insert_erc721_import_by_nft_one(
    """
    the row to be inserted
    """
    object: erc721_import_by_nft_insert_input!

    """
    on conflict condition
    """
    on_conflict: erc721_import_by_nft_on_conflict
  ): erc721_import_by_nft

  """
  insert a single row into the table: "erc721_import"
  """
  insert_erc721_import_one(
    """
    the row to be inserted
    """
    object: erc721_import_insert_input!

    """
    on conflict condition
    """
    on_conflict: erc721_import_on_conflict
  ): erc721_import

  """
  insert data into the table: "nft"
  """
  insert_nft(
    """
    the rows to be inserted
    """
    objects: [nft_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: nft_on_conflict
  ): nft_mutation_response

  """
  insert data into the table: "nft_asset"
  """
  insert_nft_asset(
    """
    the rows to be inserted
    """
    objects: [nft_asset_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: nft_asset_on_conflict
  ): nft_asset_mutation_response

  """
  insert a single row into the table: "nft_asset"
  """
  insert_nft_asset_one(
    """
    the row to be inserted
    """
    object: nft_asset_insert_input!

    """
    on conflict condition
    """
    on_conflict: nft_asset_on_conflict
  ): nft_asset

  """
  insert data into the table: "nft_metadata"
  """
  insert_nft_metadata(
    """
    the rows to be inserted
    """
    objects: [nft_metadata_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: nft_metadata_on_conflict
  ): nft_metadata_mutation_response

  """
  insert a single row into the table: "nft_metadata"
  """
  insert_nft_metadata_one(
    """
    the row to be inserted
    """
    object: nft_metadata_insert_input!

    """
    on conflict condition
    """
    on_conflict: nft_metadata_on_conflict
  ): nft_metadata

  """
  insert a single row into the table: "nft"
  """
  insert_nft_one(
    """
    the row to be inserted
    """
    object: nft_insert_input!

    """
    on conflict condition
    """
    on_conflict: nft_on_conflict
  ): nft

  """
  insert data into the table: "nft_owner"
  """
  insert_nft_owner(
    """
    the rows to be inserted
    """
    objects: [nft_owner_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: nft_owner_on_conflict
  ): nft_owner_mutation_response

  """
  insert a single row into the table: "nft_owner"
  """
  insert_nft_owner_one(
    """
    the row to be inserted
    """
    object: nft_owner_insert_input!

    """
    on conflict condition
    """
    on_conflict: nft_owner_on_conflict
  ): nft_owner

  """
  insert data into the table: "nfts_by_blockchain_blocks"
  """
  insert_nfts_by_blockchain_blocks(
    """
    the rows to be inserted
    """
    objects: [nfts_by_blockchain_blocks_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: nfts_by_blockchain_blocks_on_conflict
  ): nfts_by_blockchain_blocks_mutation_response

  """
  insert a single row into the table: "nfts_by_blockchain_blocks"
  """
  insert_nfts_by_blockchain_blocks_one(
    """
    the row to be inserted
    """
    object: nfts_by_blockchain_blocks_insert_input!

    """
    on conflict condition
    """
    on_conflict: nfts_by_blockchain_blocks_on_conflict
  ): nfts_by_blockchain_blocks

  """
  insert data into the table: "niftysave_migration"
  """
  insert_niftysave_migration(
    """
    the rows to be inserted
    """
    objects: [niftysave_migration_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: niftysave_migration_on_conflict
  ): niftysave_migration_mutation_response

  """
  insert a single row into the table: "niftysave_migration"
  """
  insert_niftysave_migration_one(
    """
    the row to be inserted
    """
    object: niftysave_migration_insert_input!

    """
    on conflict condition
    """
    on_conflict: niftysave_migration_on_conflict
  ): niftysave_migration

  """
  insert data into the table: "other_nft_resources"
  """
  insert_other_nft_resources(
    """
    the rows to be inserted
    """
    objects: [other_nft_resources_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: other_nft_resources_on_conflict
  ): other_nft_resources_mutation_response

  """
  insert a single row into the table: "other_nft_resources"
  """
  insert_other_nft_resources_one(
    """
    the row to be inserted
    """
    object: other_nft_resources_insert_input!

    """
    on conflict condition
    """
    on_conflict: other_nft_resources_on_conflict
  ): other_nft_resources

  """
  insert data into the table: "pin"
  """
  insert_pin(
    """
    the rows to be inserted
    """
    objects: [pin_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: pin_on_conflict
  ): pin_mutation_response

  """
  insert a single row into the table: "pin"
  """
  insert_pin_one(
    """
    the row to be inserted
    """
    object: pin_insert_input!

    """
    on conflict condition
    """
    on_conflict: pin_on_conflict
  ): pin

  """
  insert data into the table: "resource"
  """
  insert_resource(
    """
    the rows to be inserted
    """
    objects: [resource_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: resource_on_conflict
  ): resource_mutation_response

  """
  insert a single row into the table: "resource"
  """
  insert_resource_one(
    """
    the row to be inserted
    """
    object: resource_insert_input!

    """
    on conflict condition
    """
    on_conflict: resource_on_conflict
  ): resource

  """
  update data of the table: "blockchain_block"
  """
  update_blockchain_block(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: blockchain_block_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: blockchain_block_set_input

    """
    filter the rows which have to be updated
    """
    where: blockchain_block_bool_exp!
  ): blockchain_block_mutation_response

  """
  update single row of the table: "blockchain_block"
  """
  update_blockchain_block_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: blockchain_block_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: blockchain_block_set_input
    pk_columns: blockchain_block_pk_columns_input!
  ): blockchain_block

  """
  update data of the table: "blockchain_contract"
  """
  update_blockchain_contract(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: blockchain_contract_set_input

    """
    filter the rows which have to be updated
    """
    where: blockchain_contract_bool_exp!
  ): blockchain_contract_mutation_response

  """
  update single row of the table: "blockchain_contract"
  """
  update_blockchain_contract_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: blockchain_contract_set_input
    pk_columns: blockchain_contract_pk_columns_input!
  ): blockchain_contract

  """
  update data of the table: "content"
  """
  update_content(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: content_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: content_set_input

    """
    filter the rows which have to be updated
    """
    where: content_bool_exp!
  ): content_mutation_response

  """
  update single row of the table: "content"
  """
  update_content_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: content_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: content_set_input
    pk_columns: content_pk_columns_input!
  ): content

  """
  update data of the table: "erc721_import"
  """
  update_erc721_import(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: erc721_import_set_input

    """
    filter the rows which have to be updated
    """
    where: erc721_import_bool_exp!
  ): erc721_import_mutation_response

  """
  update data of the table: "erc721_import_by_nft"
  """
  update_erc721_import_by_nft(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: erc721_import_by_nft_set_input

    """
    filter the rows which have to be updated
    """
    where: erc721_import_by_nft_bool_exp!
  ): erc721_import_by_nft_mutation_response

  """
  update single row of the table: "erc721_import_by_nft"
  """
  update_erc721_import_by_nft_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: erc721_import_by_nft_set_input
    pk_columns: erc721_import_by_nft_pk_columns_input!
  ): erc721_import_by_nft

  """
  update single row of the table: "erc721_import"
  """
  update_erc721_import_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: erc721_import_set_input
    pk_columns: erc721_import_pk_columns_input!
  ): erc721_import

  """
  update data of the table: "nft"
  """
  update_nft(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: nft_set_input

    """
    filter the rows which have to be updated
    """
    where: nft_bool_exp!
  ): nft_mutation_response

  """
  update data of the table: "nft_asset"
  """
  update_nft_asset(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: nft_asset_set_input

    """
    filter the rows which have to be updated
    """
    where: nft_asset_bool_exp!
  ): nft_asset_mutation_response

  """
  update single row of the table: "nft_asset"
  """
  update_nft_asset_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: nft_asset_set_input
    pk_columns: nft_asset_pk_columns_input!
  ): nft_asset

  """
  update single row of the table: "nft"
  """
  update_nft_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: nft_set_input
    pk_columns: nft_pk_columns_input!
  ): nft

  """
  update data of the table: "nft_metadata"
  """
  update_nft_metadata(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: nft_metadata_set_input

    """
    filter the rows which have to be updated
    """
    where: nft_metadata_bool_exp!
  ): nft_metadata_mutation_response

  """
  update single row of the table: "nft_metadata"
  """
  update_nft_metadata_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: nft_metadata_set_input
    pk_columns: nft_metadata_pk_columns_input!
  ): nft_metadata

  """
  update data of the table: "nft_owner"
  """
  update_nft_owner(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: nft_owner_set_input

    """
    filter the rows which have to be updated
    """
    where: nft_owner_bool_exp!
  ): nft_owner_mutation_response

  """
  update single row of the table: "nft_owner"
  """
  update_nft_owner_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: nft_owner_set_input
    pk_columns: nft_owner_pk_columns_input!
  ): nft_owner

  """
  update data of the table: "nfts_by_blockchain_blocks"
  """
  update_nfts_by_blockchain_blocks(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: nfts_by_blockchain_blocks_set_input

    """
    filter the rows which have to be updated
    """
    where: nfts_by_blockchain_blocks_bool_exp!
  ): nfts_by_blockchain_blocks_mutation_response

  """
  update single row of the table: "nfts_by_blockchain_blocks"
  """
  update_nfts_by_blockchain_blocks_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: nfts_by_blockchain_blocks_set_input
    pk_columns: nfts_by_blockchain_blocks_pk_columns_input!
  ): nfts_by_blockchain_blocks

  """
  update data of the table: "niftysave_migration"
  """
  update_niftysave_migration(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: niftysave_migration_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: niftysave_migration_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: niftysave_migration_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: niftysave_migration_delete_key_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: niftysave_migration_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: niftysave_migration_set_input

    """
    filter the rows which have to be updated
    """
    where: niftysave_migration_bool_exp!
  ): niftysave_migration_mutation_response

  """
  update single row of the table: "niftysave_migration"
  """
  update_niftysave_migration_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: niftysave_migration_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: niftysave_migration_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: niftysave_migration_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: niftysave_migration_delete_key_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: niftysave_migration_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: niftysave_migration_set_input
    pk_columns: niftysave_migration_pk_columns_input!
  ): niftysave_migration

  """
  update data of the table: "other_nft_resources"
  """
  update_other_nft_resources(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: other_nft_resources_set_input

    """
    filter the rows which have to be updated
    """
    where: other_nft_resources_bool_exp!
  ): other_nft_resources_mutation_response

  """
  update single row of the table: "other_nft_resources"
  """
  update_other_nft_resources_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: other_nft_resources_set_input
    pk_columns: other_nft_resources_pk_columns_input!
  ): other_nft_resources

  """
  update data of the table: "pin"
  """
  update_pin(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: pin_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: pin_set_input

    """
    filter the rows which have to be updated
    """
    where: pin_bool_exp!
  ): pin_mutation_response

  """
  update single row of the table: "pin"
  """
  update_pin_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: pin_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: pin_set_input
    pk_columns: pin_pk_columns_input!
  ): pin

  """
  update data of the table: "resource"
  """
  update_resource(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: resource_set_input

    """
    filter the rows which have to be updated
    """
    where: resource_bool_exp!
  ): resource_mutation_response

  """
  update single row of the table: "resource"
  """
  update_resource_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: resource_set_input
    pk_columns: resource_pk_columns_input!
  ): resource
}

"""
columns and relationships of "nft"
"""
type nft {
  contract_id: String!
  id: String!
  inserted_at: timestamp!
  mint_time: timestamp!
  nft_owner_id: String!
  token_id: String!
  token_uri: String!
  updated_at: timestamp!
}

"""
aggregated selection of "nft"
"""
type nft_aggregate {
  aggregate: nft_aggregate_fields
  nodes: [nft!]!
}

"""
aggregate fields of "nft"
"""
type nft_aggregate_fields {
  count(columns: [nft_select_column!], distinct: Boolean): Int!
  max: nft_max_fields
  min: nft_min_fields
}

"""
columns and relationships of "nft_asset"
"""
type nft_asset {
  content_cid: String
  inserted_at: timestamp!
  ipfs_url: String
  status: nft_asset_status!
  status_text: String!
  token_uri: String!
  updated_at: timestamp!
}

"""
aggregated selection of "nft_asset"
"""
type nft_asset_aggregate {
  aggregate: nft_asset_aggregate_fields
  nodes: [nft_asset!]!
}

"""
aggregate fields of "nft_asset"
"""
type nft_asset_aggregate_fields {
  count(columns: [nft_asset_select_column!], distinct: Boolean): Int!
  max: nft_asset_max_fields
  min: nft_asset_min_fields
}

"""
Boolean expression to filter rows from the table "nft_asset". All fields are combined with a logical 'AND'.
"""
input nft_asset_bool_exp {
  _and: [nft_asset_bool_exp!]
  _not: nft_asset_bool_exp
  _or: [nft_asset_bool_exp!]
  content_cid: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  ipfs_url: String_comparison_exp
  status: nft_asset_status_comparison_exp
  status_text: String_comparison_exp
  token_uri: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "nft_asset"
"""
enum nft_asset_constraint {
  """
  unique or primary key constraint
  """
  nft_asset_pkey
}

"""
input type for inserting data into table "nft_asset"
"""
input nft_asset_insert_input {
  content_cid: String
  inserted_at: timestamp
  ipfs_url: String
  status: nft_asset_status
  status_text: String
  token_uri: String
  updated_at: timestamp
}

"""
aggregate max on columns
"""
type nft_asset_max_fields {
  content_cid: String
  inserted_at: timestamp
  ipfs_url: String
  status_text: String
  token_uri: String
  updated_at: timestamp
}

"""
aggregate min on columns
"""
type nft_asset_min_fields {
  content_cid: String
  inserted_at: timestamp
  ipfs_url: String
  status_text: String
  token_uri: String
  updated_at: timestamp
}

"""
response of any mutation on the table "nft_asset"
"""
type nft_asset_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [nft_asset!]!
}

"""
on conflict condition type for table "nft_asset"
"""
input nft_asset_on_conflict {
  constraint: nft_asset_constraint!
  update_columns: [nft_asset_update_column!]! = []
  where: nft_asset_bool_exp
}

"""
Ordering options when selecting data from "nft_asset".
"""
input nft_asset_order_by {
  content_cid: order_by
  inserted_at: order_by
  ipfs_url: order_by
  status: order_by
  status_text: order_by
  token_uri: order_by
  updated_at: order_by
}

"""
primary key columns input for table: nft_asset
"""
input nft_asset_pk_columns_input {
  token_uri: String!
}

"""
select columns of table "nft_asset"
"""
enum nft_asset_select_column {
  """
  column name
  """
  content_cid

  """
  column name
  """
  inserted_at

  """
  column name
  """
  ipfs_url

  """
  column name
  """
  status

  """
  column name
  """
  status_text

  """
  column name
  """
  token_uri

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "nft_asset"
"""
input nft_asset_set_input {
  content_cid: String
  inserted_at: timestamp
  ipfs_url: String
  status: nft_asset_status
  status_text: String
  token_uri: String
  updated_at: timestamp
}

scalar nft_asset_status

"""
Boolean expression to compare columns of type "nft_asset_status". All fields are combined with logical 'AND'.
"""
input nft_asset_status_comparison_exp {
  _eq: nft_asset_status
  _gt: nft_asset_status
  _gte: nft_asset_status
  _in: [nft_asset_status!]
  _is_null: Boolean
  _lt: nft_asset_status
  _lte: nft_asset_status
  _neq: nft_asset_status
  _nin: [nft_asset_status!]
}

"""
update columns of table "nft_asset"
"""
enum nft_asset_update_column {
  """
  column name
  """
  content_cid

  """
  column name
  """
  inserted_at

  """
  column name
  """
  ipfs_url

  """
  column name
  """
  status

  """
  column name
  """
  status_text

  """
  column name
  """
  token_uri

  """
  column name
  """
  updated_at
}

"""
Boolean expression to filter rows from the table "nft". All fields are combined with a logical 'AND'.
"""
input nft_bool_exp {
  _and: [nft_bool_exp!]
  _not: nft_bool_exp
  _or: [nft_bool_exp!]
  contract_id: String_comparison_exp
  id: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  mint_time: timestamp_comparison_exp
  nft_owner_id: String_comparison_exp
  token_id: String_comparison_exp
  token_uri: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "nft"
"""
enum nft_constraint {
  """
  unique or primary key constraint
  """
  nft_pkey
}

"""
input type for inserting data into table "nft"
"""
input nft_insert_input {
  contract_id: String
  id: String
  inserted_at: timestamp
  mint_time: timestamp
  nft_owner_id: String
  token_id: String
  token_uri: String
  updated_at: timestamp
}

"""
aggregate max on columns
"""
type nft_max_fields {
  contract_id: String
  id: String
  inserted_at: timestamp
  mint_time: timestamp
  nft_owner_id: String
  token_id: String
  token_uri: String
  updated_at: timestamp
}

"""
columns and relationships of "nft_metadata"
"""
type nft_metadata {
  content_cid: String!
  description: String!
  image_uri: String!
  inserted_at: timestamp!
  name: String!
  updated_at: timestamp!
}

"""
aggregated selection of "nft_metadata"
"""
type nft_metadata_aggregate {
  aggregate: nft_metadata_aggregate_fields
  nodes: [nft_metadata!]!
}

"""
aggregate fields of "nft_metadata"
"""
type nft_metadata_aggregate_fields {
  count(columns: [nft_metadata_select_column!], distinct: Boolean): Int!
  max: nft_metadata_max_fields
  min: nft_metadata_min_fields
}

"""
Boolean expression to filter rows from the table "nft_metadata". All fields are combined with a logical 'AND'.
"""
input nft_metadata_bool_exp {
  _and: [nft_metadata_bool_exp!]
  _not: nft_metadata_bool_exp
  _or: [nft_metadata_bool_exp!]
  content_cid: String_comparison_exp
  description: String_comparison_exp
  image_uri: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  name: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "nft_metadata"
"""
enum nft_metadata_constraint {
  """
  unique or primary key constraint
  """
  nft_metadata_pkey
}

"""
input type for inserting data into table "nft_metadata"
"""
input nft_metadata_insert_input {
  content_cid: String
  description: String
  image_uri: String
  inserted_at: timestamp
  name: String
  updated_at: timestamp
}

"""
aggregate max on columns
"""
type nft_metadata_max_fields {
  content_cid: String
  description: String
  image_uri: String
  inserted_at: timestamp
  name: String
  updated_at: timestamp
}

"""
aggregate min on columns
"""
type nft_metadata_min_fields {
  content_cid: String
  description: String
  image_uri: String
  inserted_at: timestamp
  name: String
  updated_at: timestamp
}

"""
response of any mutation on the table "nft_metadata"
"""
type nft_metadata_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [nft_metadata!]!
}

"""
on conflict condition type for table "nft_metadata"
"""
input nft_metadata_on_conflict {
  constraint: nft_metadata_constraint!
  update_columns: [nft_metadata_update_column!]! = []
  where: nft_metadata_bool_exp
}

"""
Ordering options when selecting data from "nft_metadata".
"""
input nft_metadata_order_by {
  content_cid: order_by
  description: order_by
  image_uri: order_by
  inserted_at: order_by
  name: order_by
  updated_at: order_by
}

"""
primary key columns input for table: nft_metadata
"""
input nft_metadata_pk_columns_input {
  content_cid: String!
}

"""
select columns of table "nft_metadata"
"""
enum nft_metadata_select_column {
  """
  column name
  """
  content_cid

  """
  column name
  """
  description

  """
  column name
  """
  image_uri

  """
  column name
  """
  inserted_at

  """
  column name
  """
  name

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "nft_metadata"
"""
input nft_metadata_set_input {
  content_cid: String
  description: String
  image_uri: String
  inserted_at: timestamp
  name: String
  updated_at: timestamp
}

"""
update columns of table "nft_metadata"
"""
enum nft_metadata_update_column {
  """
  column name
  """
  content_cid

  """
  column name
  """
  description

  """
  column name
  """
  image_uri

  """
  column name
  """
  inserted_at

  """
  column name
  """
  name

  """
  column name
  """
  updated_at
}

"""
aggregate min on columns
"""
type nft_min_fields {
  contract_id: String
  id: String
  inserted_at: timestamp
  mint_time: timestamp
  nft_owner_id: String
  token_id: String
  token_uri: String
  updated_at: timestamp
}

"""
response of any mutation on the table "nft"
"""
type nft_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [nft!]!
}

"""
on conflict condition type for table "nft"
"""
input nft_on_conflict {
  constraint: nft_constraint!
  update_columns: [nft_update_column!]! = []
  where: nft_bool_exp
}

"""
Ordering options when selecting data from "nft".
"""
input nft_order_by {
  contract_id: order_by
  id: order_by
  inserted_at: order_by
  mint_time: order_by
  nft_owner_id: order_by
  token_id: order_by
  token_uri: order_by
  updated_at: order_by
}

"""
columns and relationships of "nft_owner"
"""
type nft_owner {
  id: String!
  inserted_at: timestamp!
  updated_at: timestamp!
}

"""
aggregated selection of "nft_owner"
"""
type nft_owner_aggregate {
  aggregate: nft_owner_aggregate_fields
  nodes: [nft_owner!]!
}

"""
aggregate fields of "nft_owner"
"""
type nft_owner_aggregate_fields {
  count(columns: [nft_owner_select_column!], distinct: Boolean): Int!
  max: nft_owner_max_fields
  min: nft_owner_min_fields
}

"""
Boolean expression to filter rows from the table "nft_owner". All fields are combined with a logical 'AND'.
"""
input nft_owner_bool_exp {
  _and: [nft_owner_bool_exp!]
  _not: nft_owner_bool_exp
  _or: [nft_owner_bool_exp!]
  id: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "nft_owner"
"""
enum nft_owner_constraint {
  """
  unique or primary key constraint
  """
  nft_owner_pkey
}

"""
input type for inserting data into table "nft_owner"
"""
input nft_owner_insert_input {
  id: String
  inserted_at: timestamp
  updated_at: timestamp
}

"""
aggregate max on columns
"""
type nft_owner_max_fields {
  id: String
  inserted_at: timestamp
  updated_at: timestamp
}

"""
aggregate min on columns
"""
type nft_owner_min_fields {
  id: String
  inserted_at: timestamp
  updated_at: timestamp
}

"""
response of any mutation on the table "nft_owner"
"""
type nft_owner_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [nft_owner!]!
}

"""
on conflict condition type for table "nft_owner"
"""
input nft_owner_on_conflict {
  constraint: nft_owner_constraint!
  update_columns: [nft_owner_update_column!]! = []
  where: nft_owner_bool_exp
}

"""
Ordering options when selecting data from "nft_owner".
"""
input nft_owner_order_by {
  id: order_by
  inserted_at: order_by
  updated_at: order_by
}

"""
primary key columns input for table: nft_owner
"""
input nft_owner_pk_columns_input {
  id: String!
}

"""
select columns of table "nft_owner"
"""
enum nft_owner_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "nft_owner"
"""
input nft_owner_set_input {
  id: String
  inserted_at: timestamp
  updated_at: timestamp
}

"""
update columns of table "nft_owner"
"""
enum nft_owner_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  updated_at
}

"""
primary key columns input for table: nft
"""
input nft_pk_columns_input {
  id: String!
}

"""
select columns of table "nft"
"""
enum nft_select_column {
  """
  column name
  """
  contract_id

  """
  column name
  """
  id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  mint_time

  """
  column name
  """
  nft_owner_id

  """
  column name
  """
  token_id

  """
  column name
  """
  token_uri

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "nft"
"""
input nft_set_input {
  contract_id: String
  id: String
  inserted_at: timestamp
  mint_time: timestamp
  nft_owner_id: String
  token_id: String
  token_uri: String
  updated_at: timestamp
}

"""
update columns of table "nft"
"""
enum nft_update_column {
  """
  column name
  """
  contract_id

  """
  column name
  """
  id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  mint_time

  """
  column name
  """
  nft_owner_id

  """
  column name
  """
  token_id

  """
  column name
  """
  token_uri

  """
  column name
  """
  updated_at
}

"""
columns and relationships of "nfts_by_blockchain_blocks"
"""
type nfts_by_blockchain_blocks {
  blockchain_block_hash: String!
  inserted_at: timestamp!
  nft_id: String!
  updated_at: timestamp!
}

"""
aggregated selection of "nfts_by_blockchain_blocks"
"""
type nfts_by_blockchain_blocks_aggregate {
  aggregate: nfts_by_blockchain_blocks_aggregate_fields
  nodes: [nfts_by_blockchain_blocks!]!
}

"""
aggregate fields of "nfts_by_blockchain_blocks"
"""
type nfts_by_blockchain_blocks_aggregate_fields {
  count(
    columns: [nfts_by_blockchain_blocks_select_column!]
    distinct: Boolean
  ): Int!
  max: nfts_by_blockchain_blocks_max_fields
  min: nfts_by_blockchain_blocks_min_fields
}

"""
Boolean expression to filter rows from the table "nfts_by_blockchain_blocks". All fields are combined with a logical 'AND'.
"""
input nfts_by_blockchain_blocks_bool_exp {
  _and: [nfts_by_blockchain_blocks_bool_exp!]
  _not: nfts_by_blockchain_blocks_bool_exp
  _or: [nfts_by_blockchain_blocks_bool_exp!]
  blockchain_block_hash: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  nft_id: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "nfts_by_blockchain_blocks"
"""
enum nfts_by_blockchain_blocks_constraint {
  """
  unique or primary key constraint
  """
  nfts_by_blockchain_blocks_pkey
}

"""
input type for inserting data into table "nfts_by_blockchain_blocks"
"""
input nfts_by_blockchain_blocks_insert_input {
  blockchain_block_hash: String
  inserted_at: timestamp
  nft_id: String
  updated_at: timestamp
}

"""
aggregate max on columns
"""
type nfts_by_blockchain_blocks_max_fields {
  blockchain_block_hash: String
  inserted_at: timestamp
  nft_id: String
  updated_at: timestamp
}

"""
aggregate min on columns
"""
type nfts_by_blockchain_blocks_min_fields {
  blockchain_block_hash: String
  inserted_at: timestamp
  nft_id: String
  updated_at: timestamp
}

"""
response of any mutation on the table "nfts_by_blockchain_blocks"
"""
type nfts_by_blockchain_blocks_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [nfts_by_blockchain_blocks!]!
}

"""
on conflict condition type for table "nfts_by_blockchain_blocks"
"""
input nfts_by_blockchain_blocks_on_conflict {
  constraint: nfts_by_blockchain_blocks_constraint!
  update_columns: [nfts_by_blockchain_blocks_update_column!]! = []
  where: nfts_by_blockchain_blocks_bool_exp
}

"""
Ordering options when selecting data from "nfts_by_blockchain_blocks".
"""
input nfts_by_blockchain_blocks_order_by {
  blockchain_block_hash: order_by
  inserted_at: order_by
  nft_id: order_by
  updated_at: order_by
}

"""
primary key columns input for table: nfts_by_blockchain_blocks
"""
input nfts_by_blockchain_blocks_pk_columns_input {
  blockchain_block_hash: String!
  nft_id: String!
}

"""
select columns of table "nfts_by_blockchain_blocks"
"""
enum nfts_by_blockchain_blocks_select_column {
  """
  column name
  """
  blockchain_block_hash

  """
  column name
  """
  inserted_at

  """
  column name
  """
  nft_id

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "nfts_by_blockchain_blocks"
"""
input nfts_by_blockchain_blocks_set_input {
  blockchain_block_hash: String
  inserted_at: timestamp
  nft_id: String
  updated_at: timestamp
}

"""
update columns of table "nfts_by_blockchain_blocks"
"""
enum nfts_by_blockchain_blocks_update_column {
  """
  column name
  """
  blockchain_block_hash

  """
  column name
  """
  inserted_at

  """
  column name
  """
  nft_id

  """
  column name
  """
  updated_at
}

"""
Utility table to keep track of migrations


columns and relationships of "niftysave_migration"
"""
type niftysave_migration {
  collection: String!
  cursor: String
  id: String!
  inserted_at: timestamptz!
  metadata(
    """
    JSON select path
    """
    path: String
  ): jsonb
  updated_at: timestamptz!
}

"""
aggregated selection of "niftysave_migration"
"""
type niftysave_migration_aggregate {
  aggregate: niftysave_migration_aggregate_fields
  nodes: [niftysave_migration!]!
}

"""
aggregate fields of "niftysave_migration"
"""
type niftysave_migration_aggregate_fields {
  count(columns: [niftysave_migration_select_column!], distinct: Boolean): Int!
  max: niftysave_migration_max_fields
  min: niftysave_migration_min_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input niftysave_migration_append_input {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "niftysave_migration". All fields are combined with a logical 'AND'.
"""
input niftysave_migration_bool_exp {
  _and: [niftysave_migration_bool_exp!]
  _not: niftysave_migration_bool_exp
  _or: [niftysave_migration_bool_exp!]
  collection: String_comparison_exp
  cursor: String_comparison_exp
  id: String_comparison_exp
  inserted_at: timestamptz_comparison_exp
  metadata: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "niftysave_migration"
"""
enum niftysave_migration_constraint {
  """
  unique or primary key constraint
  """
  niftysave_migration_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input niftysave_migration_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input niftysave_migration_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input niftysave_migration_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "niftysave_migration"
"""
input niftysave_migration_insert_input {
  collection: String
  cursor: String
  id: String
  inserted_at: timestamptz
  metadata: jsonb
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type niftysave_migration_max_fields {
  collection: String
  cursor: String
  id: String
  inserted_at: timestamptz
  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type niftysave_migration_min_fields {
  collection: String
  cursor: String
  id: String
  inserted_at: timestamptz
  updated_at: timestamptz
}

"""
response of any mutation on the table "niftysave_migration"
"""
type niftysave_migration_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [niftysave_migration!]!
}

"""
on conflict condition type for table "niftysave_migration"
"""
input niftysave_migration_on_conflict {
  constraint: niftysave_migration_constraint!
  update_columns: [niftysave_migration_update_column!]! = []
  where: niftysave_migration_bool_exp
}

"""
Ordering options when selecting data from "niftysave_migration".
"""
input niftysave_migration_order_by {
  collection: order_by
  cursor: order_by
  id: order_by
  inserted_at: order_by
  metadata: order_by
  updated_at: order_by
}

"""
primary key columns input for table: niftysave_migration
"""
input niftysave_migration_pk_columns_input {
  id: String!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input niftysave_migration_prepend_input {
  metadata: jsonb
}

"""
select columns of table "niftysave_migration"
"""
enum niftysave_migration_select_column {
  """
  column name
  """
  collection

  """
  column name
  """
  cursor

  """
  column name
  """
  id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  metadata

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "niftysave_migration"
"""
input niftysave_migration_set_input {
  collection: String
  cursor: String
  id: String
  inserted_at: timestamptz
  metadata: jsonb
  updated_at: timestamptz
}

"""
update columns of table "niftysave_migration"
"""
enum niftysave_migration_update_column {
  """
  column name
  """
  collection

  """
  column name
  """
  cursor

  """
  column name
  """
  id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  metadata

  """
  column name
  """
  updated_at
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

"""
columns and relationships of "other_nft_resources"
"""
type other_nft_resources {
  content_cid: String!
  inserted_at: timestamp!
  resource_uri: String!
  updated_at: timestamp!
}

"""
aggregated selection of "other_nft_resources"
"""
type other_nft_resources_aggregate {
  aggregate: other_nft_resources_aggregate_fields
  nodes: [other_nft_resources!]!
}

"""
aggregate fields of "other_nft_resources"
"""
type other_nft_resources_aggregate_fields {
  count(columns: [other_nft_resources_select_column!], distinct: Boolean): Int!
  max: other_nft_resources_max_fields
  min: other_nft_resources_min_fields
}

"""
Boolean expression to filter rows from the table "other_nft_resources". All fields are combined with a logical 'AND'.
"""
input other_nft_resources_bool_exp {
  _and: [other_nft_resources_bool_exp!]
  _not: other_nft_resources_bool_exp
  _or: [other_nft_resources_bool_exp!]
  content_cid: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  resource_uri: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "other_nft_resources"
"""
enum other_nft_resources_constraint {
  """
  unique or primary key constraint
  """
  other_nft_resources_pkey
}

"""
input type for inserting data into table "other_nft_resources"
"""
input other_nft_resources_insert_input {
  content_cid: String
  inserted_at: timestamp
  resource_uri: String
  updated_at: timestamp
}

"""
aggregate max on columns
"""
type other_nft_resources_max_fields {
  content_cid: String
  inserted_at: timestamp
  resource_uri: String
  updated_at: timestamp
}

"""
aggregate min on columns
"""
type other_nft_resources_min_fields {
  content_cid: String
  inserted_at: timestamp
  resource_uri: String
  updated_at: timestamp
}

"""
response of any mutation on the table "other_nft_resources"
"""
type other_nft_resources_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [other_nft_resources!]!
}

"""
on conflict condition type for table "other_nft_resources"
"""
input other_nft_resources_on_conflict {
  constraint: other_nft_resources_constraint!
  update_columns: [other_nft_resources_update_column!]! = []
  where: other_nft_resources_bool_exp
}

"""
Ordering options when selecting data from "other_nft_resources".
"""
input other_nft_resources_order_by {
  content_cid: order_by
  inserted_at: order_by
  resource_uri: order_by
  updated_at: order_by
}

"""
primary key columns input for table: other_nft_resources
"""
input other_nft_resources_pk_columns_input {
  content_cid: String!
  resource_uri: String!
}

"""
select columns of table "other_nft_resources"
"""
enum other_nft_resources_select_column {
  """
  column name
  """
  content_cid

  """
  column name
  """
  inserted_at

  """
  column name
  """
  resource_uri

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "other_nft_resources"
"""
input other_nft_resources_set_input {
  content_cid: String
  inserted_at: timestamp
  resource_uri: String
  updated_at: timestamp
}

"""
update columns of table "other_nft_resources"
"""
enum other_nft_resources_update_column {
  """
  column name
  """
  content_cid

  """
  column name
  """
  inserted_at

  """
  column name
  """
  resource_uri

  """
  column name
  """
  updated_at
}

"""
columns and relationships of "pin"
"""
type pin {
  content_cid: String!
  id: bigint!
  inserted_at: timestamp!
  service: pin_service!
  status: pin_status!
  status_text: String
  updated_at: timestamp!
}

"""
aggregated selection of "pin"
"""
type pin_aggregate {
  aggregate: pin_aggregate_fields
  nodes: [pin!]!
}

"""
aggregate fields of "pin"
"""
type pin_aggregate_fields {
  avg: pin_avg_fields
  count(columns: [pin_select_column!], distinct: Boolean): Int!
  max: pin_max_fields
  min: pin_min_fields
  stddev: pin_stddev_fields
  stddev_pop: pin_stddev_pop_fields
  stddev_samp: pin_stddev_samp_fields
  sum: pin_sum_fields
  var_pop: pin_var_pop_fields
  var_samp: pin_var_samp_fields
  variance: pin_variance_fields
}

"""
aggregate avg on columns
"""
type pin_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "pin". All fields are combined with a logical 'AND'.
"""
input pin_bool_exp {
  _and: [pin_bool_exp!]
  _not: pin_bool_exp
  _or: [pin_bool_exp!]
  content_cid: String_comparison_exp
  id: bigint_comparison_exp
  inserted_at: timestamp_comparison_exp
  service: pin_service_comparison_exp
  status: pin_status_comparison_exp
  status_text: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "pin"
"""
enum pin_constraint {
  """
  unique or primary key constraint
  """
  pin_pkey
}

"""
input type for incrementing numeric columns in table "pin"
"""
input pin_inc_input {
  id: bigint
}

"""
input type for inserting data into table "pin"
"""
input pin_insert_input {
  content_cid: String
  id: bigint
  inserted_at: timestamp
  service: pin_service
  status: pin_status
  status_text: String
  updated_at: timestamp
}

"""
aggregate max on columns
"""
type pin_max_fields {
  content_cid: String
  id: bigint
  inserted_at: timestamp
  status_text: String
  updated_at: timestamp
}

"""
aggregate min on columns
"""
type pin_min_fields {
  content_cid: String
  id: bigint
  inserted_at: timestamp
  status_text: String
  updated_at: timestamp
}

"""
response of any mutation on the table "pin"
"""
type pin_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [pin!]!
}

"""
on conflict condition type for table "pin"
"""
input pin_on_conflict {
  constraint: pin_constraint!
  update_columns: [pin_update_column!]! = []
  where: pin_bool_exp
}

"""
Ordering options when selecting data from "pin".
"""
input pin_order_by {
  content_cid: order_by
  id: order_by
  inserted_at: order_by
  service: order_by
  status: order_by
  status_text: order_by
  updated_at: order_by
}

"""
primary key columns input for table: pin
"""
input pin_pk_columns_input {
  id: bigint!
}

"""
select columns of table "pin"
"""
enum pin_select_column {
  """
  column name
  """
  content_cid

  """
  column name
  """
  id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  service

  """
  column name
  """
  status

  """
  column name
  """
  status_text

  """
  column name
  """
  updated_at
}

scalar pin_service

"""
Boolean expression to compare columns of type "pin_service". All fields are combined with logical 'AND'.
"""
input pin_service_comparison_exp {
  _eq: pin_service
  _gt: pin_service
  _gte: pin_service
  _in: [pin_service!]
  _is_null: Boolean
  _lt: pin_service
  _lte: pin_service
  _neq: pin_service
  _nin: [pin_service!]
}

"""
input type for updating data in table "pin"
"""
input pin_set_input {
  content_cid: String
  id: bigint
  inserted_at: timestamp
  service: pin_service
  status: pin_status
  status_text: String
  updated_at: timestamp
}

scalar pin_status

"""
Boolean expression to compare columns of type "pin_status". All fields are combined with logical 'AND'.
"""
input pin_status_comparison_exp {
  _eq: pin_status
  _gt: pin_status
  _gte: pin_status
  _in: [pin_status!]
  _is_null: Boolean
  _lt: pin_status
  _lte: pin_status
  _neq: pin_status
  _nin: [pin_status!]
}

"""
aggregate stddev on columns
"""
type pin_stddev_fields {
  id: Float
}

"""
aggregate stddev_pop on columns
"""
type pin_stddev_pop_fields {
  id: Float
}

"""
aggregate stddev_samp on columns
"""
type pin_stddev_samp_fields {
  id: Float
}

"""
aggregate sum on columns
"""
type pin_sum_fields {
  id: bigint
}

"""
update columns of table "pin"
"""
enum pin_update_column {
  """
  column name
  """
  content_cid

  """
  column name
  """
  id

  """
  column name
  """
  inserted_at

  """
  column name
  """
  service

  """
  column name
  """
  status

  """
  column name
  """
  status_text

  """
  column name
  """
  updated_at
}

"""
aggregate var_pop on columns
"""
type pin_var_pop_fields {
  id: Float
}

"""
aggregate var_samp on columns
"""
type pin_var_samp_fields {
  id: Float
}

"""
aggregate variance on columns
"""
type pin_variance_fields {
  id: Float
}

type query_root {
  """
  fetch data from the table: "blockchain_block"
  """
  blockchain_block(
    """
    distinct select on columns
    """
    distinct_on: [blockchain_block_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [blockchain_block_order_by!]

    """
    filter the rows returned
    """
    where: blockchain_block_bool_exp
  ): [blockchain_block!]!

  """
  fetch aggregated fields from the table: "blockchain_block"
  """
  blockchain_block_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [blockchain_block_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [blockchain_block_order_by!]

    """
    filter the rows returned
    """
    where: blockchain_block_bool_exp
  ): blockchain_block_aggregate!

  """
  fetch data from the table: "blockchain_block" using primary key columns
  """
  blockchain_block_by_pk(hash: String!): blockchain_block

  """
  fetch data from the table: "blockchain_contract"
  """
  blockchain_contract(
    """
    distinct select on columns
    """
    distinct_on: [blockchain_contract_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [blockchain_contract_order_by!]

    """
    filter the rows returned
    """
    where: blockchain_contract_bool_exp
  ): [blockchain_contract!]!

  """
  fetch aggregated fields from the table: "blockchain_contract"
  """
  blockchain_contract_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [blockchain_contract_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [blockchain_contract_order_by!]

    """
    filter the rows returned
    """
    where: blockchain_contract_bool_exp
  ): blockchain_contract_aggregate!

  """
  fetch data from the table: "blockchain_contract" using primary key columns
  """
  blockchain_contract_by_pk(id: String!): blockchain_contract

  """
  fetch data from the table: "content"
  """
  content(
    """
    distinct select on columns
    """
    distinct_on: [content_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [content_order_by!]

    """
    filter the rows returned
    """
    where: content_bool_exp
  ): [content!]!

  """
  fetch aggregated fields from the table: "content"
  """
  content_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [content_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [content_order_by!]

    """
    filter the rows returned
    """
    where: content_bool_exp
  ): content_aggregate!

  """
  fetch data from the table: "content" using primary key columns
  """
  content_by_pk(cid: String!): content

  """
  fetch data from the table: "erc721_import"
  """
  erc721_import(
    """
    distinct select on columns
    """
    distinct_on: [erc721_import_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [erc721_import_order_by!]

    """
    filter the rows returned
    """
    where: erc721_import_bool_exp
  ): [erc721_import!]!

  """
  fetch aggregated fields from the table: "erc721_import"
  """
  erc721_import_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [erc721_import_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [erc721_import_order_by!]

    """
    filter the rows returned
    """
    where: erc721_import_bool_exp
  ): erc721_import_aggregate!

  """
  fetch data from the table: "erc721_import_by_nft"
  """
  erc721_import_by_nft(
    """
    distinct select on columns
    """
    distinct_on: [erc721_import_by_nft_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [erc721_import_by_nft_order_by!]

    """
    filter the rows returned
    """
    where: erc721_import_by_nft_bool_exp
  ): [erc721_import_by_nft!]!

  """
  fetch aggregated fields from the table: "erc721_import_by_nft"
  """
  erc721_import_by_nft_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [erc721_import_by_nft_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [erc721_import_by_nft_order_by!]

    """
    filter the rows returned
    """
    where: erc721_import_by_nft_bool_exp
  ): erc721_import_by_nft_aggregate!

  """
  fetch data from the table: "erc721_import_by_nft" using primary key columns
  """
  erc721_import_by_nft_by_pk(
    erc721_import_id: String!
    nft_id: String!
  ): erc721_import_by_nft

  """
  fetch data from the table: "erc721_import" using primary key columns
  """
  erc721_import_by_pk(id: String!): erc721_import

  """
  fetch data from the table: "nft"
  """
  nft(
    """
    distinct select on columns
    """
    distinct_on: [nft_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_order_by!]

    """
    filter the rows returned
    """
    where: nft_bool_exp
  ): [nft!]!

  """
  fetch aggregated fields from the table: "nft"
  """
  nft_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [nft_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_order_by!]

    """
    filter the rows returned
    """
    where: nft_bool_exp
  ): nft_aggregate!

  """
  fetch data from the table: "nft_asset"
  """
  nft_asset(
    """
    distinct select on columns
    """
    distinct_on: [nft_asset_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_asset_order_by!]

    """
    filter the rows returned
    """
    where: nft_asset_bool_exp
  ): [nft_asset!]!

  """
  fetch aggregated fields from the table: "nft_asset"
  """
  nft_asset_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [nft_asset_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_asset_order_by!]

    """
    filter the rows returned
    """
    where: nft_asset_bool_exp
  ): nft_asset_aggregate!

  """
  fetch data from the table: "nft_asset" using primary key columns
  """
  nft_asset_by_pk(token_uri: String!): nft_asset

  """
  fetch data from the table: "nft" using primary key columns
  """
  nft_by_pk(id: String!): nft

  """
  fetch data from the table: "nft_metadata"
  """
  nft_metadata(
    """
    distinct select on columns
    """
    distinct_on: [nft_metadata_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_metadata_order_by!]

    """
    filter the rows returned
    """
    where: nft_metadata_bool_exp
  ): [nft_metadata!]!

  """
  fetch aggregated fields from the table: "nft_metadata"
  """
  nft_metadata_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [nft_metadata_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_metadata_order_by!]

    """
    filter the rows returned
    """
    where: nft_metadata_bool_exp
  ): nft_metadata_aggregate!

  """
  fetch data from the table: "nft_metadata" using primary key columns
  """
  nft_metadata_by_pk(content_cid: String!): nft_metadata

  """
  fetch data from the table: "nft_owner"
  """
  nft_owner(
    """
    distinct select on columns
    """
    distinct_on: [nft_owner_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_owner_order_by!]

    """
    filter the rows returned
    """
    where: nft_owner_bool_exp
  ): [nft_owner!]!

  """
  fetch aggregated fields from the table: "nft_owner"
  """
  nft_owner_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [nft_owner_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_owner_order_by!]

    """
    filter the rows returned
    """
    where: nft_owner_bool_exp
  ): nft_owner_aggregate!

  """
  fetch data from the table: "nft_owner" using primary key columns
  """
  nft_owner_by_pk(id: String!): nft_owner

  """
  fetch data from the table: "nfts_by_blockchain_blocks"
  """
  nfts_by_blockchain_blocks(
    """
    distinct select on columns
    """
    distinct_on: [nfts_by_blockchain_blocks_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nfts_by_blockchain_blocks_order_by!]

    """
    filter the rows returned
    """
    where: nfts_by_blockchain_blocks_bool_exp
  ): [nfts_by_blockchain_blocks!]!

  """
  fetch aggregated fields from the table: "nfts_by_blockchain_blocks"
  """
  nfts_by_blockchain_blocks_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [nfts_by_blockchain_blocks_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nfts_by_blockchain_blocks_order_by!]

    """
    filter the rows returned
    """
    where: nfts_by_blockchain_blocks_bool_exp
  ): nfts_by_blockchain_blocks_aggregate!

  """
  fetch data from the table: "nfts_by_blockchain_blocks" using primary key columns
  """
  nfts_by_blockchain_blocks_by_pk(
    blockchain_block_hash: String!
    nft_id: String!
  ): nfts_by_blockchain_blocks

  """
  fetch data from the table: "niftysave_migration"
  """
  niftysave_migration(
    """
    distinct select on columns
    """
    distinct_on: [niftysave_migration_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [niftysave_migration_order_by!]

    """
    filter the rows returned
    """
    where: niftysave_migration_bool_exp
  ): [niftysave_migration!]!

  """
  fetch aggregated fields from the table: "niftysave_migration"
  """
  niftysave_migration_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [niftysave_migration_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [niftysave_migration_order_by!]

    """
    filter the rows returned
    """
    where: niftysave_migration_bool_exp
  ): niftysave_migration_aggregate!

  """
  fetch data from the table: "niftysave_migration" using primary key columns
  """
  niftysave_migration_by_pk(id: String!): niftysave_migration

  """
  fetch data from the table: "other_nft_resources"
  """
  other_nft_resources(
    """
    distinct select on columns
    """
    distinct_on: [other_nft_resources_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [other_nft_resources_order_by!]

    """
    filter the rows returned
    """
    where: other_nft_resources_bool_exp
  ): [other_nft_resources!]!

  """
  fetch aggregated fields from the table: "other_nft_resources"
  """
  other_nft_resources_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [other_nft_resources_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [other_nft_resources_order_by!]

    """
    filter the rows returned
    """
    where: other_nft_resources_bool_exp
  ): other_nft_resources_aggregate!

  """
  fetch data from the table: "other_nft_resources" using primary key columns
  """
  other_nft_resources_by_pk(
    content_cid: String!
    resource_uri: String!
  ): other_nft_resources

  """
  fetch data from the table: "pin"
  """
  pin(
    """
    distinct select on columns
    """
    distinct_on: [pin_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [pin_order_by!]

    """
    filter the rows returned
    """
    where: pin_bool_exp
  ): [pin!]!

  """
  fetch aggregated fields from the table: "pin"
  """
  pin_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [pin_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [pin_order_by!]

    """
    filter the rows returned
    """
    where: pin_bool_exp
  ): pin_aggregate!

  """
  fetch data from the table: "pin" using primary key columns
  """
  pin_by_pk(id: bigint!): pin

  """
  fetch data from the table: "resource"
  """
  resource(
    """
    distinct select on columns
    """
    distinct_on: [resource_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [resource_order_by!]

    """
    filter the rows returned
    """
    where: resource_bool_exp
  ): [resource!]!

  """
  fetch aggregated fields from the table: "resource"
  """
  resource_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [resource_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [resource_order_by!]

    """
    filter the rows returned
    """
    where: resource_bool_exp
  ): resource_aggregate!

  """
  fetch data from the table: "resource" using primary key columns
  """
  resource_by_pk(uri: String!): resource
}

"""
columns and relationships of "resource"
"""
type resource {
  content_cid: String
  inserted_at: timestamp!
  ipfs_url: String
  status: resource_status!
  status_text: String
  updated_at: timestamp!
  uri: String!
}

"""
aggregated selection of "resource"
"""
type resource_aggregate {
  aggregate: resource_aggregate_fields
  nodes: [resource!]!
}

"""
aggregate fields of "resource"
"""
type resource_aggregate_fields {
  count(columns: [resource_select_column!], distinct: Boolean): Int!
  max: resource_max_fields
  min: resource_min_fields
}

"""
Boolean expression to filter rows from the table "resource". All fields are combined with a logical 'AND'.
"""
input resource_bool_exp {
  _and: [resource_bool_exp!]
  _not: resource_bool_exp
  _or: [resource_bool_exp!]
  content_cid: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  ipfs_url: String_comparison_exp
  status: resource_status_comparison_exp
  status_text: String_comparison_exp
  updated_at: timestamp_comparison_exp
  uri: String_comparison_exp
}

"""
unique or primary key constraints on table "resource"
"""
enum resource_constraint {
  """
  unique or primary key constraint
  """
  resource_pkey
}

"""
input type for inserting data into table "resource"
"""
input resource_insert_input {
  content_cid: String
  inserted_at: timestamp
  ipfs_url: String
  status: resource_status
  status_text: String
  updated_at: timestamp
  uri: String
}

"""
aggregate max on columns
"""
type resource_max_fields {
  content_cid: String
  inserted_at: timestamp
  ipfs_url: String
  status_text: String
  updated_at: timestamp
  uri: String
}

"""
aggregate min on columns
"""
type resource_min_fields {
  content_cid: String
  inserted_at: timestamp
  ipfs_url: String
  status_text: String
  updated_at: timestamp
  uri: String
}

"""
response of any mutation on the table "resource"
"""
type resource_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [resource!]!
}

"""
on conflict condition type for table "resource"
"""
input resource_on_conflict {
  constraint: resource_constraint!
  update_columns: [resource_update_column!]! = []
  where: resource_bool_exp
}

"""
Ordering options when selecting data from "resource".
"""
input resource_order_by {
  content_cid: order_by
  inserted_at: order_by
  ipfs_url: order_by
  status: order_by
  status_text: order_by
  updated_at: order_by
  uri: order_by
}

"""
primary key columns input for table: resource
"""
input resource_pk_columns_input {
  uri: String!
}

"""
select columns of table "resource"
"""
enum resource_select_column {
  """
  column name
  """
  content_cid

  """
  column name
  """
  inserted_at

  """
  column name
  """
  ipfs_url

  """
  column name
  """
  status

  """
  column name
  """
  status_text

  """
  column name
  """
  updated_at

  """
  column name
  """
  uri
}

"""
input type for updating data in table "resource"
"""
input resource_set_input {
  content_cid: String
  inserted_at: timestamp
  ipfs_url: String
  status: resource_status
  status_text: String
  updated_at: timestamp
  uri: String
}

scalar resource_status

"""
Boolean expression to compare columns of type "resource_status". All fields are combined with logical 'AND'.
"""
input resource_status_comparison_exp {
  _eq: resource_status
  _gt: resource_status
  _gte: resource_status
  _in: [resource_status!]
  _is_null: Boolean
  _lt: resource_status
  _lte: resource_status
  _neq: resource_status
  _nin: [resource_status!]
}

"""
update columns of table "resource"
"""
enum resource_update_column {
  """
  column name
  """
  content_cid

  """
  column name
  """
  inserted_at

  """
  column name
  """
  ipfs_url

  """
  column name
  """
  status

  """
  column name
  """
  status_text

  """
  column name
  """
  updated_at

  """
  column name
  """
  uri
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

type subscription_root {
  """
  fetch data from the table: "blockchain_block"
  """
  blockchain_block(
    """
    distinct select on columns
    """
    distinct_on: [blockchain_block_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [blockchain_block_order_by!]

    """
    filter the rows returned
    """
    where: blockchain_block_bool_exp
  ): [blockchain_block!]!

  """
  fetch aggregated fields from the table: "blockchain_block"
  """
  blockchain_block_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [blockchain_block_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [blockchain_block_order_by!]

    """
    filter the rows returned
    """
    where: blockchain_block_bool_exp
  ): blockchain_block_aggregate!

  """
  fetch data from the table: "blockchain_block" using primary key columns
  """
  blockchain_block_by_pk(hash: String!): blockchain_block

  """
  fetch data from the table: "blockchain_contract"
  """
  blockchain_contract(
    """
    distinct select on columns
    """
    distinct_on: [blockchain_contract_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [blockchain_contract_order_by!]

    """
    filter the rows returned
    """
    where: blockchain_contract_bool_exp
  ): [blockchain_contract!]!

  """
  fetch aggregated fields from the table: "blockchain_contract"
  """
  blockchain_contract_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [blockchain_contract_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [blockchain_contract_order_by!]

    """
    filter the rows returned
    """
    where: blockchain_contract_bool_exp
  ): blockchain_contract_aggregate!

  """
  fetch data from the table: "blockchain_contract" using primary key columns
  """
  blockchain_contract_by_pk(id: String!): blockchain_contract

  """
  fetch data from the table: "content"
  """
  content(
    """
    distinct select on columns
    """
    distinct_on: [content_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [content_order_by!]

    """
    filter the rows returned
    """
    where: content_bool_exp
  ): [content!]!

  """
  fetch aggregated fields from the table: "content"
  """
  content_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [content_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [content_order_by!]

    """
    filter the rows returned
    """
    where: content_bool_exp
  ): content_aggregate!

  """
  fetch data from the table: "content" using primary key columns
  """
  content_by_pk(cid: String!): content

  """
  fetch data from the table: "erc721_import"
  """
  erc721_import(
    """
    distinct select on columns
    """
    distinct_on: [erc721_import_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [erc721_import_order_by!]

    """
    filter the rows returned
    """
    where: erc721_import_bool_exp
  ): [erc721_import!]!

  """
  fetch aggregated fields from the table: "erc721_import"
  """
  erc721_import_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [erc721_import_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [erc721_import_order_by!]

    """
    filter the rows returned
    """
    where: erc721_import_bool_exp
  ): erc721_import_aggregate!

  """
  fetch data from the table: "erc721_import_by_nft"
  """
  erc721_import_by_nft(
    """
    distinct select on columns
    """
    distinct_on: [erc721_import_by_nft_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [erc721_import_by_nft_order_by!]

    """
    filter the rows returned
    """
    where: erc721_import_by_nft_bool_exp
  ): [erc721_import_by_nft!]!

  """
  fetch aggregated fields from the table: "erc721_import_by_nft"
  """
  erc721_import_by_nft_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [erc721_import_by_nft_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [erc721_import_by_nft_order_by!]

    """
    filter the rows returned
    """
    where: erc721_import_by_nft_bool_exp
  ): erc721_import_by_nft_aggregate!

  """
  fetch data from the table: "erc721_import_by_nft" using primary key columns
  """
  erc721_import_by_nft_by_pk(
    erc721_import_id: String!
    nft_id: String!
  ): erc721_import_by_nft

  """
  fetch data from the table: "erc721_import" using primary key columns
  """
  erc721_import_by_pk(id: String!): erc721_import

  """
  fetch data from the table: "nft"
  """
  nft(
    """
    distinct select on columns
    """
    distinct_on: [nft_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_order_by!]

    """
    filter the rows returned
    """
    where: nft_bool_exp
  ): [nft!]!

  """
  fetch aggregated fields from the table: "nft"
  """
  nft_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [nft_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_order_by!]

    """
    filter the rows returned
    """
    where: nft_bool_exp
  ): nft_aggregate!

  """
  fetch data from the table: "nft_asset"
  """
  nft_asset(
    """
    distinct select on columns
    """
    distinct_on: [nft_asset_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_asset_order_by!]

    """
    filter the rows returned
    """
    where: nft_asset_bool_exp
  ): [nft_asset!]!

  """
  fetch aggregated fields from the table: "nft_asset"
  """
  nft_asset_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [nft_asset_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_asset_order_by!]

    """
    filter the rows returned
    """
    where: nft_asset_bool_exp
  ): nft_asset_aggregate!

  """
  fetch data from the table: "nft_asset" using primary key columns
  """
  nft_asset_by_pk(token_uri: String!): nft_asset

  """
  fetch data from the table: "nft" using primary key columns
  """
  nft_by_pk(id: String!): nft

  """
  fetch data from the table: "nft_metadata"
  """
  nft_metadata(
    """
    distinct select on columns
    """
    distinct_on: [nft_metadata_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_metadata_order_by!]

    """
    filter the rows returned
    """
    where: nft_metadata_bool_exp
  ): [nft_metadata!]!

  """
  fetch aggregated fields from the table: "nft_metadata"
  """
  nft_metadata_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [nft_metadata_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_metadata_order_by!]

    """
    filter the rows returned
    """
    where: nft_metadata_bool_exp
  ): nft_metadata_aggregate!

  """
  fetch data from the table: "nft_metadata" using primary key columns
  """
  nft_metadata_by_pk(content_cid: String!): nft_metadata

  """
  fetch data from the table: "nft_owner"
  """
  nft_owner(
    """
    distinct select on columns
    """
    distinct_on: [nft_owner_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_owner_order_by!]

    """
    filter the rows returned
    """
    where: nft_owner_bool_exp
  ): [nft_owner!]!

  """
  fetch aggregated fields from the table: "nft_owner"
  """
  nft_owner_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [nft_owner_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nft_owner_order_by!]

    """
    filter the rows returned
    """
    where: nft_owner_bool_exp
  ): nft_owner_aggregate!

  """
  fetch data from the table: "nft_owner" using primary key columns
  """
  nft_owner_by_pk(id: String!): nft_owner

  """
  fetch data from the table: "nfts_by_blockchain_blocks"
  """
  nfts_by_blockchain_blocks(
    """
    distinct select on columns
    """
    distinct_on: [nfts_by_blockchain_blocks_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nfts_by_blockchain_blocks_order_by!]

    """
    filter the rows returned
    """
    where: nfts_by_blockchain_blocks_bool_exp
  ): [nfts_by_blockchain_blocks!]!

  """
  fetch aggregated fields from the table: "nfts_by_blockchain_blocks"
  """
  nfts_by_blockchain_blocks_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [nfts_by_blockchain_blocks_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [nfts_by_blockchain_blocks_order_by!]

    """
    filter the rows returned
    """
    where: nfts_by_blockchain_blocks_bool_exp
  ): nfts_by_blockchain_blocks_aggregate!

  """
  fetch data from the table: "nfts_by_blockchain_blocks" using primary key columns
  """
  nfts_by_blockchain_blocks_by_pk(
    blockchain_block_hash: String!
    nft_id: String!
  ): nfts_by_blockchain_blocks

  """
  fetch data from the table: "niftysave_migration"
  """
  niftysave_migration(
    """
    distinct select on columns
    """
    distinct_on: [niftysave_migration_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [niftysave_migration_order_by!]

    """
    filter the rows returned
    """
    where: niftysave_migration_bool_exp
  ): [niftysave_migration!]!

  """
  fetch aggregated fields from the table: "niftysave_migration"
  """
  niftysave_migration_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [niftysave_migration_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [niftysave_migration_order_by!]

    """
    filter the rows returned
    """
    where: niftysave_migration_bool_exp
  ): niftysave_migration_aggregate!

  """
  fetch data from the table: "niftysave_migration" using primary key columns
  """
  niftysave_migration_by_pk(id: String!): niftysave_migration

  """
  fetch data from the table: "other_nft_resources"
  """
  other_nft_resources(
    """
    distinct select on columns
    """
    distinct_on: [other_nft_resources_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [other_nft_resources_order_by!]

    """
    filter the rows returned
    """
    where: other_nft_resources_bool_exp
  ): [other_nft_resources!]!

  """
  fetch aggregated fields from the table: "other_nft_resources"
  """
  other_nft_resources_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [other_nft_resources_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [other_nft_resources_order_by!]

    """
    filter the rows returned
    """
    where: other_nft_resources_bool_exp
  ): other_nft_resources_aggregate!

  """
  fetch data from the table: "other_nft_resources" using primary key columns
  """
  other_nft_resources_by_pk(
    content_cid: String!
    resource_uri: String!
  ): other_nft_resources

  """
  fetch data from the table: "pin"
  """
  pin(
    """
    distinct select on columns
    """
    distinct_on: [pin_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [pin_order_by!]

    """
    filter the rows returned
    """
    where: pin_bool_exp
  ): [pin!]!

  """
  fetch aggregated fields from the table: "pin"
  """
  pin_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [pin_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [pin_order_by!]

    """
    filter the rows returned
    """
    where: pin_bool_exp
  ): pin_aggregate!

  """
  fetch data from the table: "pin" using primary key columns
  """
  pin_by_pk(id: bigint!): pin

  """
  fetch data from the table: "resource"
  """
  resource(
    """
    distinct select on columns
    """
    distinct_on: [resource_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [resource_order_by!]

    """
    filter the rows returned
    """
    where: resource_bool_exp
  ): [resource!]!

  """
  fetch aggregated fields from the table: "resource"
  """
  resource_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [resource_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [resource_order_by!]

    """
    filter the rows returned
    """
    where: resource_bool_exp
  ): resource_aggregate!

  """
  fetch data from the table: "resource" using primary key columns
  """
  resource_by_pk(uri: String!): resource
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}
